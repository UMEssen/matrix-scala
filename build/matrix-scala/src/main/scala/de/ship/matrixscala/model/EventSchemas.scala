/**
  * <h1>matrix-scala</h1>
  * @version 1.0.0
  * @author kirill.sokol@uk-essen.de
  *
  * This file was generated.
  *
  * DO NOT EDIT THIS FILE. Any changes to this file will be overwritten
  * the next time the code is generated. If you need to modify the code
  * generated by this tool, make your changes to the generator script
  * and regenerate the code.
  */

package de.ship.matrixscala.model

import de.ship.matrixscala.core._
import de.ship.matrixscala.model.Definitions
import spray.json.{JsObject, JsValue}

object EventSchemas {

  object MTag {

    object TypeEnum extends Enumeration {

      val `m.tag`: Value = Value("m.tag")

    }

    object Content {

      /**
        * <h1>Tag</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.tag.yaml"
        */
      case class Tag(
          order: Option[Float] = None
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.tag.yaml"
      */
    case class Content(
        tags: Option[Map[String, EventSchemas.MTag.Content.Tag]] = None
    )

  }

  /**
    * <h1>MTag</h1>
    *
    *  Informs the client of tags on a room.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.tag.yaml"
    */
  case class MTag(
      //composite start Definitions.Event

      // composite end
      `type`: EventSchemas.MTag.TypeEnum.Value = EventSchemas.MTag.TypeEnum.`m.tag`,
      content: EventSchemas.MTag.Content
  )

  object MPolicyRuleRoom {

    object TypeEnum extends Enumeration {

      val `m.policy.rule.room`: Value = Value("m.policy.rule.room")

    }

  }

  /**
    * <h1>MPolicyRuleRoom</h1>
    *
    *  A moderation policy rule which affects room IDs and room aliases.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.policy.rule.room.yaml"
    */
  case class MPolicyRuleRoom(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[Definitions.ModerationPolicyRule] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MPolicyRuleRoom.TypeEnum.Value] = None
  )

  object MRoomThirdPartyInvite {

    object Content {

      /**
        * <h1>PublicKeys</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.third_party_invite.yaml"
        */
      case class PublicKeys(
          key_validity_url: Option[String] = None,
          public_key: String
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.third_party_invite.yaml"
      */
    case class Content(
        display_name: String,
        key_validity_url: String,
        public_key: String,
        public_keys: Option[Seq[EventSchemas.MRoomThirdPartyInvite.Content.PublicKeys]] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.third_party_invite`: Value = Value("m.room.third_party_invite")

    }

  }

  /**
    * <h1>MRoomThirdPartyInvite</h1>
    *
    *  Acts as an `m.room.member` invite event, where there isn't a target user_id to invite. This event contains a token and a public key whose private key must be used to sign the token. Any user who can present that signature may use this invitation to join the target room.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.third_party_invite.yaml"
    */
  case class MRoomThirdPartyInvite(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomThirdPartyInvite.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomThirdPartyInvite.TypeEnum.Value] = None
  )

  object MKeyVerificationRequest {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.request.yaml"
      */
    case class Content(
        from_device: String,
        transaction_id: Option[String] = None,
        methods: Seq[String],
        timestamp: Option[Long] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.request`: Value = Value("m.key.verification.request")

    }

  }

  /**
    * <h1>MKeyVerificationRequest</h1>
    *
    *  Requests a key verification using to-device messaging.  When requesting a key
    * verification in a room, a `m.room.message` should be used, with
    * [`m.key.verification.request`](#mroommessagemkeyverificationrequest) as msgtype.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.request.yaml"
    */
  case class MKeyVerificationRequest(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationRequest.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationRequest.TypeEnum.Value] = None
  )

  object MRoomMessageMFile {

    object Content {

      /**
        * <h1>FileInfo</h1>
        *
        *  Information about the file referred to in `url`.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.file.yaml"
        */
      case class FileInfo(
          mimetype: Option[String] = None,
          size: Option[Int] = None,
          thumbnail_url: Option[String] = None,
          thumbnail_file: Option[JsObject] = None,
          thumbnail_info: Option[Definitions.ThumbnailInfo] = None
      )

      object MsgtypeEnum extends Enumeration {

        val `m.file`: Value = Value("m.file")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.file.yaml"
      */
    case class Content(
        body: String,
        filename: Option[String] = None,
        info: Option[EventSchemas.MRoomMessageMFile.Content.FileInfo] = None,
        msgtype: EventSchemas.MRoomMessageMFile.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMFile.Content.MsgtypeEnum.`m.file`,
        url: Option[String] = None,
        file: Option[JsObject] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMFile</h1>
    *
    *  This message represents a generic file.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.file.yaml"
    */
  case class MRoomMessageMFile(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMFile.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMFile.TypeEnum.Value] = None
  )

  object MReceipt {

    object TypeEnum extends Enumeration {

      val `m.receipt`: Value = Value("m.receipt")

      val `m.receipt.private`: Value = Value("m.receipt.private")

    }

  }

  /**
    * <h1>MReceipt</h1>
    *
    *  Informs the client of new receipts.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.receipt.yaml"
    */
  case class MReceipt(
      //composite start Definitions.Event

      // composite end
      content: JsObject,
      `type`: EventSchemas.MReceipt.TypeEnum.Value
  )

  object MIgnoredUserList {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.ignored_user_list.yaml"
      */
    case class Content(
        ignored_users: JsObject
    )

    object TypeEnum extends Enumeration {

      val `m.ignored_user_list`: Value = Value("m.ignored_user_list")

    }

  }

  /**
    * <h1>MIgnoredUserList</h1>
    *
    *  A map of users which are considered ignored is kept in `account_data`
    * in an event type of `m.ignored_user_list`.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.ignored_user_list.yaml"
    */
  case class MIgnoredUserList(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MIgnoredUserList.Content] = None,
      `type`: Option[EventSchemas.MIgnoredUserList.TypeEnum.Value] = None
  )

  object MForwardedRoomKey {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.forwarded_room_key.yaml"
      */
    case class Content(
        algorithm: String,
        room_id: String,
        sender_key: String,
        session_id: String,
        session_key: String,
        sender_claimed_ed25519_key: String,
        forwarding_curve25519_key_chain: Seq[String],
        withheld: Option[JsObject] = None
    )

    object TypeEnum extends Enumeration {

      val `m.forwarded_room_key`: Value = Value("m.forwarded_room_key")

    }

  }

  /**
    * <h1>MForwardedRoomKey</h1>
    *
    *  This event type is used to forward keys for end-to-end encryption.
    * It is encrypted as an `m.room.encrypted` event using [Olm](#molmv1curve25519-aes-sha2),
    * then sent as a [to-device](/client-server-api/#send-to-device-messaging) event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.forwarded_room_key.yaml"
    */
  case class MForwardedRoomKey(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MForwardedRoomKey.Content] = None,
      `type`: Option[EventSchemas.MForwardedRoomKey.TypeEnum.Value] = None
  )

  object MSecretSend {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.secret.send.yaml"
      */
    case class Content(
        request_id: String,
        secret: String
    )

    object TypeEnum extends Enumeration {

      val `m.secret.send`: Value = Value("m.secret.send")

    }

  }

  /**
    * <h1>MSecretSend</h1>
    *
    *  Sent by a client to share a secret with another device, in response to an
    * `m.secret.request` event. It must be encrypted as an `m.room.encrypted` event
    * using [Olm](#molmv1curve25519-aes-sha2), then sent as a to-device event.
    *
    * The `request_id` must match the ID previously given in an `m.secret.request`
    * event. The recipient must ensure that this event comes from a device that the
    * `m.secret.request` event was originally sent to, and that the device is
    * a verified device owned by the recipient. This should be done by checking the
    * sender key of the Olm session that the event was sent over.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.secret.send.yaml"
    */
  case class MSecretSend(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MSecretSend.Content] = None,
      `type`: Option[EventSchemas.MSecretSend.TypeEnum.Value] = None
  )

  object MRoomMessageMVideo {

    object Content {

      /**
        * <h1>VideoInfo</h1>
        *
        *  Metadata about the video clip referred to in `url`.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.video.yaml"
        */
      case class VideoInfo(
          duration: Option[Int] = None,
          h: Option[Int] = None,
          w: Option[Int] = None,
          mimetype: Option[String] = None,
          size: Option[Int] = None,
          thumbnail_url: Option[String] = None,
          thumbnail_file: Option[JsObject] = None,
          thumbnail_info: Option[Definitions.ThumbnailInfo] = None
      )

      object MsgtypeEnum extends Enumeration {

        val `m.video`: Value = Value("m.video")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.video.yaml"
      */
    case class Content(
        body: String,
        info: Option[EventSchemas.MRoomMessageMVideo.Content.VideoInfo] = None,
        msgtype: EventSchemas.MRoomMessageMVideo.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMVideo.Content.MsgtypeEnum.`m.video`,
        url: Option[String] = None,
        file: Option[JsObject] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMVideo</h1>
    *
    *  This message represents a single video clip.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.video.yaml"
    */
  case class MRoomMessageMVideo(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMVideo.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMVideo.TypeEnum.Value] = None
  )

  object MRoomKeyRequest {

    object Content {

      /**
        * <h1>RequestedKeyInfo</h1>
        *
        *  Information about the requested key. Required when `action` is
        * `request`.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key_request.yaml"
        */
      case class RequestedKeyInfo(
          algorithm: String,
          room_id: String,
          sender_key: Option[String] = None,
          session_id: String
      )

      object ActionEnum extends Enumeration {

        val `request`: Value = Value("request")

        val `request_cancellation`: Value = Value("request_cancellation")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key_request.yaml"
      */
    case class Content(
        body: Option[EventSchemas.MRoomKeyRequest.Content.RequestedKeyInfo] = None,
        action: EventSchemas.MRoomKeyRequest.Content.ActionEnum.Value,
        requesting_device_id: String,
        request_id: String
    )

    object TypeEnum extends Enumeration {

      val `m.room_key_request`: Value = Value("m.room_key_request")

    }

  }

  /**
    * <h1>MRoomKeyRequest</h1>
    *
    *  This event type is used to request keys for end-to-end encryption. It is sent as an
    * unencrypted [to-device](/client-server-api/#send-to-device-messaging) event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key_request.yaml"
    */
  case class MRoomKeyRequest(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MRoomKeyRequest.Content] = None,
      `type`: Option[EventSchemas.MRoomKeyRequest.TypeEnum.Value] = None
  )

  object MRoomMessage {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message.yaml"
      */
    case class Content(
        body: String,
        msgtype: String
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessage</h1>
    *
    *  This event is used when sending messages in a room. Messages are not limited to be text. The `msgtype` key outlines the type of message, e.g. text, audio, image, video, etc. The `body` key is text and MUST be used with every kind of `msgtype` as a fallback mechanism for when a client cannot render a message. This allows clients to display *something* even if it is just plain text.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message.yaml"
    */
  case class MRoomMessage(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessage.Content] = None,
      `type`: Option[EventSchemas.MRoomMessage.TypeEnum.Value] = None
  )

  object MKeyVerificationCancel {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.cancel.yaml"
      */
    case class Content(
        transaction_id: Option[String] = None,
        reason: String,
        code: String,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.cancel`: Value = Value("m.key.verification.cancel")

    }

  }

  /**
    * <h1>MKeyVerificationCancel</h1>
    *
    *  Cancels a key verification process/request.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.cancel.yaml"
    */
  case class MKeyVerificationCancel(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationCancel.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationCancel.TypeEnum.Value] = None
  )

  object MSticker {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.sticker.yaml"
      */
    case class Content(
        body: String,
        info: Definitions.ImageInfo,
        url: String
    )

    object TypeEnum extends Enumeration {

      val `m.sticker`: Value = Value("m.sticker")

    }

  }

  /**
    * <h1>MSticker</h1>
    *
    *  This message represents a single sticker image.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.sticker.yaml"
    */
  case class MSticker(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MSticker.Content] = None,
      `type`: Option[EventSchemas.MSticker.TypeEnum.Value] = None
  )

  object MKeyVerificationAccept {

    object Content {

      object ShortAuthenticationStringEnum extends Enumeration {

        val `decimal`: Value = Value("decimal")

        val `emoji`: Value = Value("emoji")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.accept.yaml"
      */
    case class Content(
        transaction_id: Option[String] = None,
        key_agreement_protocol: String,
        hash: String,
        message_authentication_code: String,
        short_authentication_string: Seq[
          EventSchemas.MKeyVerificationAccept.Content.ShortAuthenticationStringEnum.Value
        ],
        commitment: String,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.accept`: Value = Value("m.key.verification.accept")

    }

  }

  /**
    * <h1>MKeyVerificationAccept</h1>
    *
    *  Accepts a previously sent `m.key.verification.start` message.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.accept.yaml"
    */
  case class MKeyVerificationAccept(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationAccept.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationAccept.TypeEnum.Value] = None
  )

  object MKeyVerificationStartMSasV1 {

    object Content {

      object MethodEnum extends Enumeration {

        val `m.sas.v1`: Value = Value("m.sas.v1")

      }

      object ShortAuthenticationStringEnum extends Enumeration {

        val `decimal`: Value = Value("decimal")

        val `emoji`: Value = Value("emoji")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start$m.sas.v1.yaml"
      */
    case class Content(
        from_device: String,
        transaction_id: Option[String] = None,
        method: EventSchemas.MKeyVerificationStartMSasV1.Content.MethodEnum.Value =
          EventSchemas.MKeyVerificationStartMSasV1.Content.MethodEnum.`m.sas.v1`,
        key_agreement_protocols: Seq[String],
        hashes: Seq[String],
        message_authentication_codes: Seq[String],
        short_authentication_string: Seq[
          EventSchemas.MKeyVerificationStartMSasV1.Content.ShortAuthenticationStringEnum.Value
        ],
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.start`: Value = Value("m.key.verification.start")

    }

  }

  /**
    * <h1>MKeyVerificationStartMSasV1</h1>
    *
    *  Begins a SAS key verification process using the `m.sas.v1` method.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start$m.sas.v1.yaml"
    */
  case class MKeyVerificationStartMSasV1(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationStartMSasV1.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationStartMSasV1.TypeEnum.Value] = None
  )

  object MPushRules {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.push_rules.yaml"
      */
    case class Content(
        global: Option[Definitions.PushRuleset] = None
    )

    object TypeEnum extends Enumeration {

      val `m.push_rules`: Value = Value("m.push_rules")

    }

  }

  /**
    * <h1>MPushRules</h1>
    *
    *  Describes all push rules for this user.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.push_rules.yaml"
    */
  case class MPushRules(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MPushRules.Content] = None,
      `type`: Option[EventSchemas.MPushRules.TypeEnum.Value] = None
  )

  object MRoomPinnedEvents {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.pinned_events.yaml"
      */
    case class Content(
        pinned: Seq[String]
    )

    object TypeEnum extends Enumeration {

      val `m.room.pinned_events`: Value = Value("m.room.pinned_events")

    }

  }

  /**
    * <h1>MRoomPinnedEvents</h1>
    *
    *  This event is used to "pin" particular events in a room for other participants to review later. The order of the pinned events is guaranteed and based upon the order supplied in the event. Clients should be aware that the current user may not be able to see some of the events pinned due to visibility settings in the room. Clients are responsible for determining if a particular event in the pinned list is displayable, and have the option to not display it if it cannot be pinned in the client.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.pinned_events.yaml"
    */
  case class MRoomPinnedEvents(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomPinnedEvents.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomPinnedEvents.TypeEnum.Value] = None
  )

  object MPolicyRuleUser {

    object TypeEnum extends Enumeration {

      val `m.policy.rule.user`: Value = Value("m.policy.rule.user")

    }

  }

  /**
    * <h1>MPolicyRuleUser</h1>
    *
    *  A moderation policy rule which affects users.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.policy.rule.user.yaml"
    */
  case class MPolicyRuleUser(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[Definitions.ModerationPolicyRule] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MPolicyRuleUser.TypeEnum.Value] = None
  )

  object MFullyRead {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.fully_read.yaml"
      */
    case class Content(
        event_id: String
    )

    object TypeEnum extends Enumeration {

      val `m.fully_read`: Value = Value("m.fully_read")

    }

  }

  /**
    * <h1>MFullyRead</h1>
    *
    *  The current location of the user's read marker in a room. This event appears in the user's room account data for the room the marker is applicable for.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.fully_read.yaml"
    */
  case class MFullyRead(
      //composite start Definitions.Event

      // composite end
      content: EventSchemas.MFullyRead.Content,
      `type`: EventSchemas.MFullyRead.TypeEnum.Value =
        EventSchemas.MFullyRead.TypeEnum.`m.fully_read`
  )

  object MRoomHistoryVisibility {

    object Content {

      object HistoryVisibilityEnum extends Enumeration {

        val `invited`: Value = Value("invited")

        val `joined`: Value = Value("joined")

        val `shared`: Value = Value("shared")

        val `world_readable`: Value = Value("world_readable")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.history_visibility.yaml"
      */
    case class Content(
        history_visibility: EventSchemas.MRoomHistoryVisibility.Content.HistoryVisibilityEnum.Value
    )

    object TypeEnum extends Enumeration {

      val `m.room.history_visibility`: Value = Value("m.room.history_visibility")

    }

  }

  /**
    * <h1>MRoomHistoryVisibility</h1>
    *
    *  This event controls whether a user can see the events that happened in a room from before they joined.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.history_visibility.yaml"
    */
  case class MRoomHistoryVisibility(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomHistoryVisibility.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomHistoryVisibility.TypeEnum.Value] = None
  )

  object MRoomKey {

    object Content {

      object AlgorithmEnum extends Enumeration {

        val `m.megolm.v1.aes-sha2`: Value = Value("m.megolm.v1.aes-sha2")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key.yaml"
      */
    case class Content(
        algorithm: EventSchemas.MRoomKey.Content.AlgorithmEnum.Value =
          EventSchemas.MRoomKey.Content.AlgorithmEnum.`m.megolm.v1.aes-sha2`,
        room_id: String,
        session_id: String,
        session_key: String
    )

    object TypeEnum extends Enumeration {

      val `m.room_key`: Value = Value("m.room_key")

    }

  }

  /**
    * <h1>MRoomKey</h1>
    *
    *  This event type is used to exchange keys for end-to-end encryption.
    * It is encrypted as an `m.room.encrypted` event using [Olm](#molmv1curve25519-aes-sha2),
    * then sent as a [to-device](/client-server-api/#send-to-device-messaging) event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key.yaml"
    */
  case class MRoomKey(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MRoomKey.Content] = None,
      `type`: Option[EventSchemas.MRoomKey.TypeEnum.Value] = None
  )

  object MSpaceChild {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.space.child.yaml"
      */
    case class Content(
        via: Option[Seq[String]] = None,
        order: Option[String] = None,
        suggested: Option[Boolean] = None
    )

    object TypeEnum extends Enumeration {

      val `m.space.child`: Value = Value("m.space.child")

    }

  }

  /**
    * <h1>MSpaceChild</h1>
    *
    *  Defines the relationship of a child room to a space-room. Has no effect in rooms which are not [spaces](#spaces).
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.space.child.yaml"
    */
  case class MSpaceChild(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MSpaceChild.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MSpaceChild.TypeEnum.Value] = None
  )

  object MRoomServerAcl {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.server_acl.yaml"
      */
    case class Content(
        allow_ip_literals: Option[Boolean] = None,
        allow: Option[Seq[String]] = None,
        deny: Option[Seq[String]] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.server_acl`: Value = Value("m.room.server_acl")

    }

  }

  /**
    * <h1>MRoomServerAcl</h1>
    *
    *  An event to indicate which servers are permitted to participate in the
    * room. Server ACLs may allow or deny groups of hosts. All servers participating
    * in the room, including those that are denied, are expected to uphold the
    * server ACL. Servers that do not uphold the ACLs MUST be added to the denied hosts
    * list in order for the ACLs to remain effective.
    *
    * The `allow` and `deny` lists are lists of [glob-style patterns](/appendices#glob-style-matching).
    * When comparing against the server ACLs, the suspect server's port
    * number must not be considered. Therefore `evil.com`, `evil.com:8448`, and
    * `evil.com:1234` would all match rules that apply to `evil.com`, for example.
    *
    * The ACLs are applied to servers when they make requests, and are applied in
    * the following order:
    *
    * 1. If there is no `m.room.server_acl` event in the room state, allow.
    * 2. If the server name is an IP address (v4 or v6) literal, and `allow_ip_literals`
    *   is present and `false`, deny.
    * 3. If the server name matches an entry in the `deny` list, deny.
    * 4. If the server name matches an entry in the `allow` list, allow.
    * 5. Otherwise, deny.
    *
    * *Note:**
    * Server ACLs do not restrict the events relative to the room DAG via authorisation
    * rules, but instead act purely at the network layer to determine which servers are
    * allowed to connect and interact with a given room.
    *
    * *Warning:**
    * Failing to provide an `allow` rule of some kind will prevent **all**
    * servers from participating in the room, including the sender. This renders
    * the room unusable. A common allow rule is `[ "*" ]` which would still
    * permit the use of the `deny` list without losing the room.
    *
    * *Warning:**
    * All compliant servers must implement server ACLs.  However, legacy or noncompliant
    * servers exist which do not uphold ACLs, and these MUST be manually appended to
    * the denied hosts list when setting an ACL to prevent them from leaking events from
    * banned servers into a room. Currently, the only way to determine noncompliant hosts is
    * to check the `prev_events` of leaked events, therefore detecting servers which
    * are not upholding the ACLs. Server versions can also be used to try to detect hosts that
    * will not uphold the ACLs, although this is not comprehensive. Server ACLs were added
    * in Synapse v0.32.0, although other server implementations and versions exist in the world.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.server_acl.yaml"
    */
  case class MRoomServerAcl(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomServerAcl.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomServerAcl.TypeEnum.Value] = None
  )

  object MRoomEncrypted {

    object Content {

      object AlgorithmEnum extends Enumeration {

        val `m.olm.v1.curve25519-aes-sha2`: Value = Value("m.olm.v1.curve25519-aes-sha2")

        val `m.megolm.v1.aes-sha2`: Value = Value("m.megolm.v1.aes-sha2")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.encrypted.yaml"
      */
    case class Content(
        algorithm: EventSchemas.MRoomEncrypted.Content.AlgorithmEnum.Value,
        ciphertext: JsObject,
        sender_key: Option[String] = None,
        device_id: Option[String] = None,
        session_id: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.encrypted`: Value = Value("m.room.encrypted")

    }

  }

  /**
    * <h1>MRoomEncrypted</h1>
    *
    *  This event type is used when sending encrypted events. It can be used either
    * within a room (in which case it will have all of the normal properties in
    * [Room events](/client-server-api/#room-event-format)), or
    * as a [to-device](/client-server-api/#send-to-device-messaging) event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.encrypted.yaml"
    */
  case class MRoomEncrypted(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MRoomEncrypted.Content] = None,
      `type`: Option[EventSchemas.MRoomEncrypted.TypeEnum.Value] = None
  )

  object MRoomMessageMText {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.text`: Value = Value("m.text")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.text.yaml"
      */
    case class Content(
        body: String,
        msgtype: EventSchemas.MRoomMessageMText.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMText.Content.MsgtypeEnum.`m.text`,
        format: Option[String] = None,
        formatted_body: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMText</h1>
    *
    *  This message is the most basic message and is used to represent text.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.text.yaml"
    */
  case class MRoomMessageMText(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMText.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMText.TypeEnum.Value] = None
  )

  object MRoomCanonicalAlias {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.canonical_alias.yaml"
      */
    case class Content(
        alias: Option[String] = None,
        alt_aliases: Option[Seq[String]] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.canonical_alias`: Value = Value("m.room.canonical_alias")

    }

  }

  /**
    * <h1>MRoomCanonicalAlias</h1>
    *
    *  This event is used to inform the room about which alias should be
    * considered the canonical one, and which other aliases point to the room.
    * This could be for display purposes or as suggestion to users which alias
    * to use to advertise and access the room.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.canonical_alias.yaml"
    */
  case class MRoomCanonicalAlias(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomCanonicalAlias.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomCanonicalAlias.TypeEnum.Value] = None
  )

  object MRoomMessageMKeyVerificationRequest {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.key.verification.request`: Value = Value("m.key.verification.request")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.key.verification.request.yaml"
      */
    case class Content(
        body: Option[String] = None,
        format: Option[String] = None,
        formatted_body: Option[String] = None,
        from_device: String,
        methods: Seq[String],
        to: String,
        msgtype: EventSchemas.MRoomMessageMKeyVerificationRequest.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMKeyVerificationRequest.Content.MsgtypeEnum.`m.key.verification.request`
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMKeyVerificationRequest</h1>
    *
    *  Requests a key verification in a room.  When requesting a key verification using to-device messaging, an event with type [`m.key.verification.request`](#mkeyverificationrequest) should be used.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.key.verification.request.yaml"
    */
  case class MRoomMessageMKeyVerificationRequest(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMKeyVerificationRequest.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMKeyVerificationRequest.TypeEnum.Value] = None
  )

  object MRoomAvatar {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.avatar.yaml"
      */
    case class Content(
        info: Option[Definitions.ImageInfo] = None,
        url: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.avatar`: Value = Value("m.room.avatar")

    }

  }

  /**
    * <h1>MRoomAvatar</h1>
    *
    *  A picture that is associated with the room. This can be displayed alongside the room information.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.avatar.yaml"
    */
  case class MRoomAvatar(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomAvatar.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomAvatar.TypeEnum.Value] = None
  )

  object MKeyVerificationKey {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.key.yaml"
      */
    case class Content(
        transaction_id: Option[String] = None,
        key: String,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.key`: Value = Value("m.key.verification.key")

    }

  }

  /**
    * <h1>MKeyVerificationKey</h1>
    *
    *  Sends the ephemeral public key for a device to the partner device.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.key.yaml"
    */
  case class MKeyVerificationKey(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationKey.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationKey.TypeEnum.Value] = None
  )

  object MRoomMessageMEmote {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.emote`: Value = Value("m.emote")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.emote.yaml"
      */
    case class Content(
        body: String,
        msgtype: EventSchemas.MRoomMessageMEmote.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMEmote.Content.MsgtypeEnum.`m.emote`,
        format: Option[String] = None,
        formatted_body: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMEmote</h1>
    *
    *  This message is similar to `m.text` except that the sender is 'performing' the action contained in the `body` key, similar to `/me` in IRC. This message should be prefixed by the name of the sender. This message could also be represented in a different colour to distinguish it from regular `m.text` messages.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.emote.yaml"
    */
  case class MRoomMessageMEmote(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMEmote.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMEmote.TypeEnum.Value] = None
  )

  object MKeyVerificationMac {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.mac.yaml"
      */
    case class Content(
        transaction_id: Option[String] = None,
        mac: Map[String, String],
        keys: String,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.mac`: Value = Value("m.key.verification.mac")

    }

  }

  /**
    * <h1>MKeyVerificationMac</h1>
    *
    *  Sends the MAC of a device's key to the partner device.  The MAC is calculated
    * using the method given in `message_authentication_code` property of the
    * `m.key.verification.accept` message.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.mac.yaml"
    */
  case class MKeyVerificationMac(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationMac.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationMac.TypeEnum.Value] = None
  )

  object MCallHangup {

    object Content {

      object ReasonEnum extends Enumeration {

        val `ice_failed`: Value = Value("ice_failed")

        val `invite_timeout`: Value = Value("invite_timeout")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.hangup.yaml"
      */
    case class Content(
        call_id: String,
        version: Int,
        reason: Option[EventSchemas.MCallHangup.Content.ReasonEnum.Value] = None
    )

    object TypeEnum extends Enumeration {

      val `m.call.hangup`: Value = Value("m.call.hangup")

    }

  }

  /**
    * <h1>MCallHangup</h1>
    *
    *  Sent by either party to signal their termination of the call. This can be sent either once the call has has been established or before to abort the call.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.hangup.yaml"
    */
  case class MCallHangup(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MCallHangup.Content] = None,
      `type`: Option[EventSchemas.MCallHangup.TypeEnum.Value] = None
  )

  object MRoomCreate {

    object Content {

      /**
        * <h1>PreviousRoom</h1>
        *
        *  A reference to the room this room replaces, if the previous room was upgraded.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.create.yaml"
        */
      case class PreviousRoom(
          room_id: String,
          event_id: String
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.create.yaml"
      */
    case class Content(
        creator: String,
        `m.federate`: Option[Boolean] = None,
        room_version: Option[String] = None,
        `type`: Option[String] = None,
        predecessor: Option[EventSchemas.MRoomCreate.Content.PreviousRoom] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.create`: Value = Value("m.room.create")

    }

  }

  /**
    * <h1>MRoomCreate</h1>
    *
    *  This is the first event in a room and cannot be changed. It acts as the root of all other events.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.create.yaml"
    */
  case class MRoomCreate(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomCreate.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomCreate.TypeEnum.Value] = None
  )

  object MRoomMessageMImage {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.image`: Value = Value("m.image")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.image.yaml"
      */
    case class Content(
        body: String,
        info: Option[Definitions.ImageInfo] = None,
        msgtype: EventSchemas.MRoomMessageMImage.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMImage.Content.MsgtypeEnum.`m.image`,
        url: Option[String] = None,
        file: Option[JsObject] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMImage</h1>
    *
    *  This message represents a single image and an optional thumbnail.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.image.yaml"
    */
  case class MRoomMessageMImage(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMImage.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMImage.TypeEnum.Value] = None
  )

  object MReaction {

    object Content {

      object ReactionRelatesTo {

        object RelTypeEnum extends Enumeration {

          val `m.annotation`: Value = Value("m.annotation")

        }

      }

      /**
        * <h1>ReactionRelatesTo</h1>
        *
        *  Indicates the event being reacted to, and the type of reaction.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.reaction.yaml"
        */
      case class ReactionRelatesTo(
          rel_type: Option[EventSchemas.MReaction.Content.ReactionRelatesTo.RelTypeEnum.Value] =
            None,
          event_id: Option[String] = None,
          key: Option[String] = None
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.reaction.yaml"
      */
    case class Content(
        `m.relates_to`: Option[EventSchemas.MReaction.Content.ReactionRelatesTo] = None
    )

  }

  /**
    * <h1>MReaction</h1>
    *
    *  Indicates a reaction to a previous event.
    *
    * Has no defined `content` properties of its own. Its only purpose is to hold an
    * [`m.relates_to`](/client-server-api/#definition-mrelates_to) property.
    *
    * Since they contain no content other than `m.relates_to`, `m.reaction` events
    * are normally not encrypted, as there would be no benefit in doing so.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.reaction.yaml"
    */
  case class MReaction(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MReaction.Content] = None
  )

  object MRoomMessageMLocation {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.location`: Value = Value("m.location")

      }

      /**
        * <h1>LocationInfo</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.location.yaml"
        */
      case class LocationInfo(
          thumbnail_url: Option[String] = None,
          thumbnail_file: Option[JsObject] = None,
          thumbnail_info: Option[Definitions.ThumbnailInfo] = None
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.location.yaml"
      */
    case class Content(
        body: String,
        geo_uri: String,
        msgtype: EventSchemas.MRoomMessageMLocation.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMLocation.Content.MsgtypeEnum.`m.location`,
        info: Option[EventSchemas.MRoomMessageMLocation.Content.LocationInfo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMLocation</h1>
    *
    *  This message represents a real-world location.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.location.yaml"
    */
  case class MRoomMessageMLocation(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMLocation.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMLocation.TypeEnum.Value] = None
  )

  object MDummy {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.dummy.yaml"
      */
    case class Content(
    )

    object TypeEnum extends Enumeration {

      val `m.dummy`: Value = Value("m.dummy")

    }

  }

  /**
    * <h1>MDummy</h1>
    *
    *  This event type is used to indicate new Olm sessions for end-to-end encryption.
    * Typically it is encrypted as an `m.room.encrypted` event, then sent as a [to-device](/client-server-api/#send-to-device-messaging)
    * event.
    *
    * The event does not have any content associated with it. The sending client is expected
    * to send a key share request shortly after this message, causing the receiving client to
    * process this `m.dummy` event as the most recent event and using the keyshare request
    * to set up the session. The keyshare request and `m.dummy` combination should result
    * in the original sending client receiving keys over the newly established session.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.dummy.yaml"
    */
  case class MDummy(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MDummy.Content] = None,
      `type`: Option[EventSchemas.MDummy.TypeEnum.Value] = None
  )

  object MCallAnswer {

    object Content {

      object Answer {

        object TypeEnum extends Enumeration {

          val `answer`: Value = Value("answer")

        }

      }

      /**
        * <h1>Answer</h1>
        *
        *  The session description object
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.answer.yaml"
        */
      case class Answer(
          `type`: EventSchemas.MCallAnswer.Content.Answer.TypeEnum.Value =
            EventSchemas.MCallAnswer.Content.Answer.TypeEnum.`answer`,
          sdp: String
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.answer.yaml"
      */
    case class Content(
        call_id: String,
        answer: EventSchemas.MCallAnswer.Content.Answer,
        version: Double
    )

    object TypeEnum extends Enumeration {

      val `m.call.answer`: Value = Value("m.call.answer")

    }

  }

  /**
    * <h1>MCallAnswer</h1>
    *
    *  This event is sent by the callee when they wish to answer the call.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.answer.yaml"
    */
  case class MCallAnswer(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MCallAnswer.Content] = None,
      `type`: Option[EventSchemas.MCallAnswer.TypeEnum.Value] = None
  )

  object MRoomTombstone {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.tombstone.yaml"
      */
    case class Content(
        body: String,
        replacement_room: String
    )

    object TypeEnum extends Enumeration {

      val `m.room.tombstone`: Value = Value("m.room.tombstone")

    }

  }

  /**
    * <h1>MRoomTombstone</h1>
    *
    *  A state event signifying that a room has been upgraded to a different room version, and that clients should go there.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.tombstone.yaml"
    */
  case class MRoomTombstone(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomTombstone.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomTombstone.TypeEnum.Value] = None
  )

  object MRoomJoinRules {

    object Content {

      object JoinRuleEnum extends Enumeration {

        val `public`: Value = Value("public")

        val `knock`: Value = Value("knock")

        val `invite`: Value = Value("invite")

        val `private`: Value = Value("private")

        val `restricted`: Value = Value("restricted")

      }

      object AllowCondition {

        object TypeEnum extends Enumeration {

          val `m.room_membership`: Value = Value("m.room_membership")

        }

      }

      /**
        * <h1>AllowCondition</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.join_rules.yaml"
        */
      case class AllowCondition(
          `type`: EventSchemas.MRoomJoinRules.Content.AllowCondition.TypeEnum.Value =
            EventSchemas.MRoomJoinRules.Content.AllowCondition.TypeEnum.`m.room_membership`,
          room_id: Option[String] = None
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.join_rules.yaml"
      */
    case class Content(
        join_rule: EventSchemas.MRoomJoinRules.Content.JoinRuleEnum.Value,
        allow: Option[Seq[EventSchemas.MRoomJoinRules.Content.AllowCondition]] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.join_rules`: Value = Value("m.room.join_rules")

    }

  }

  /**
    * <h1>MRoomJoinRules</h1>
    *
    *  A room may have one of the following designations:
    * `public` - anyone can join the room without any prior action.
    * `invite` - a user must first receive an invite from someone already in the room
    *  in order to join.
    * `knock` - a user can request an invite to the room. They can be allowed (invited)
    *  or denied (kicked/banned) access. Otherwise, users need to be invited in. Only
    *  available in rooms [which support knocking](/rooms/#feature-matrix).
    * `restricted` - anyone able to satisfy at least one of the allow conditions is
    *  able to join the room without prior action. Otherwise, an invite is required.
    *  Only available in rooms [which support the join rule](/rooms/#feature-matrix).
    * `knock_restricted` - a user can request an invite using the same functions offered
    *  by the `knock` join rule, or can attempt to join having satisfied an allow condition
    *  per the `restricted` join rule. Only available in rooms
    *  [which support the join rule](/rooms/#feature-matrix).
    * `private` - reserved without implementation. No significant meaning.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.join_rules.yaml"
    */
  case class MRoomJoinRules(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomJoinRules.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomJoinRules.TypeEnum.Value] = None
  )

  object MRoomName {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.name.yaml"
      */
    case class Content(
        name: String
    )

    object TypeEnum extends Enumeration {

      val `m.room.name`: Value = Value("m.room.name")

    }

  }

  /**
    * <h1>MRoomName</h1>
    *
    *  A room has an opaque room ID which is not human-friendly to read. A room
    * alias is human-friendly, but not all rooms have room aliases. The room name
    * is a human-friendly string designed to be displayed to the end-user. The
    * room name is not unique, as multiple rooms can have the same room name set.
    *
    * A room with an `m.room.name` event with an absent, null, or empty
    * `name` field should be treated the same as a room with no `m.room.name`
    * event.
    *
    * An event of this type is automatically created when creating a room using
    * `/createRoom` with the `name` key.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.name.yaml"
    */
  case class MRoomName(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomName.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomName.TypeEnum.Value] = None
  )

  object MRoomGuestAccess {

    object Content {

      object GuestAccessEnum extends Enumeration {

        val `can_join`: Value = Value("can_join")

        val `forbidden`: Value = Value("forbidden")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.guest_access.yaml"
      */
    case class Content(
        guest_access: EventSchemas.MRoomGuestAccess.Content.GuestAccessEnum.Value
    )

    object TypeEnum extends Enumeration {

      val `m.room.guest_access`: Value = Value("m.room.guest_access")

    }

  }

  /**
    * <h1>MRoomGuestAccess</h1>
    *
    *  This event controls whether guest users are allowed to join rooms. If this event is absent, servers should act as if it is present and has the guest_access value "forbidden".
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.guest_access.yaml"
    */
  case class MRoomGuestAccess(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomGuestAccess.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomGuestAccess.TypeEnum.Value] = None
  )

  object MRoomMessageMServerNotice {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.server_notice`: Value = Value("m.server_notice")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.server_notice.yaml"
      */
    case class Content(
        body: String,
        msgtype: EventSchemas.MRoomMessageMServerNotice.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMServerNotice.Content.MsgtypeEnum.`m.server_notice`,
        server_notice_type: String,
        admin_contact: Option[String] = None,
        limit_type: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMServerNotice</h1>
    *
    *  Represents a server notice for a user.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.server_notice.yaml"
    */
  case class MRoomMessageMServerNotice(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMServerNotice.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMServerNotice.TypeEnum.Value] = None
  )

  object MIdentityServer {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.identity_server.yaml"
      */
    case class Content(
        base_url: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.identity_server`: Value = Value("m.identity_server")

    }

  }

  /**
    * <h1>MIdentityServer</h1>
    *
    *  Persists the user's preferred identity server, or preference to not use
    * an identity server at all, in the user's account data.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.identity_server.yaml"
    */
  case class MIdentityServer(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MIdentityServer.Content] = None,
      `type`: Option[EventSchemas.MIdentityServer.TypeEnum.Value] = None
  )

  object MTyping {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.typing.yaml"
      */
    case class Content(
        user_ids: Seq[String]
    )

    object TypeEnum extends Enumeration {

      val `m.typing`: Value = Value("m.typing")

    }

  }

  /**
    * <h1>MTyping</h1>
    *
    *  Informs the client of the list of users currently typing.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.typing.yaml"
    */
  case class MTyping(
      //composite start Definitions.Event

      // composite end
      content: EventSchemas.MTyping.Content,
      `type`: EventSchemas.MTyping.TypeEnum.Value = EventSchemas.MTyping.TypeEnum.`m.typing`
  )

  object MRoomPowerLevels {

    object Content {

      /**
        * <h1>Notifications</h1>
        *
        *  The power level requirements for specific notification types.
        * This is a mapping from `key` to power level for that notifications key.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.power_levels.yaml"
        */
      case class Notifications(
          room: Option[Int] = None
      ) extends AdditionalFields[EventSchemas.MRoomPowerLevels.Content.Notifications, Int]

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.power_levels.yaml"
      */
    case class Content(
        ban: Option[Int] = None,
        events: Option[Map[String, Int]] = None,
        events_default: Option[Int] = None,
        invite: Option[Int] = None,
        kick: Option[Int] = None,
        redact: Option[Int] = None,
        state_default: Option[Int] = None,
        users: Option[Map[String, Int]] = None,
        users_default: Option[Int] = None,
        notifications: Option[EventSchemas.MRoomPowerLevels.Content.Notifications] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.power_levels`: Value = Value("m.room.power_levels")

    }

  }

  /**
    * <h1>MRoomPowerLevels</h1>
    *
    *  This event specifies the minimum level a user must have in order to perform a
    * certain action. It also specifies the levels of each user in the room.
    *
    * If a `user_id` is in the `users` list, then that `user_id` has the
    * associated power level. Otherwise they have the default level
    * `users_default`. If `users_default` is not supplied, it is assumed to be
    * 0. If the room contains no `m.room.power_levels` event, the room's creator has
    * a power level of 100, and all other users have a power level of 0.
    *
    * The level required to send a certain event is governed by `events`,
    * `state_default` and `events_default`. If an event type is specified in
    * `events`, then the user must have at least the level specified in order to
    * send that event. If the event type is not supplied, it defaults to
    * `events_default` for Message Events and `state_default` for State
    * Events.
    *
    * If there is no `state_default` in the `m.room.power_levels` event, or
    * there is no `m.room.power_levels` event, the `state_default` is 50.
    * If there is no `events_default` in the `m.room.power_levels` event,
    * or there is no `m.room.power_levels` event, the `events_default` is 0.
    *
    * The power level required to invite a user to the room, kick a user from the
    * room, ban a user from the room, or redact an event sent by another user, is
    * defined by `invite`, `kick`, `ban`, and `redact`, respectively.  The levels
    * for `kick`, `ban` and `redact` default to 50 if they are not specified in the
    * `m.room.power_levels` event, or if the room contains no `m.room.power_levels`
    * event. `invite` defaults to 0 in either case.
    *
    * *Note:**
    *
    * The allowed range for power level values is `[-(2**53)+1, (2**53)-1]`,
    * as required by the [Canonical JSON specification](/appendices/#canonical-json).
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.power_levels.yaml"
    */
  case class MRoomPowerLevels(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomPowerLevels.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomPowerLevels.TypeEnum.Value] = None
  )

  object MKeyVerificationStart {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start.yaml"
      */
    case class Content(
        from_device: String,
        transaction_id: Option[String] = None,
        method: String,
        next_method: Option[String] = None,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.start`: Value = Value("m.key.verification.start")

    }

  }

  /**
    * <h1>MKeyVerificationStart</h1>
    *
    *  Begins a key verification process. Typically sent as a [to-device](/client-server-api/#send-to-device-messaging) event. The `method`
    * field determines the type of verification. The fields in the event will differ depending
    * on the `method`. This definition includes fields that are in common among all variants.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start.yaml"
    */
  case class MKeyVerificationStart(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationStart.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationStart.TypeEnum.Value] = None
  )

  object MRoomMember {

    object EventContent {

      object MembershipEnum extends Enumeration {

        val `invite`: Value = Value("invite")

        val `join`: Value = Value("join")

        val `knock`: Value = Value("knock")

        val `leave`: Value = Value("leave")

        val `ban`: Value = Value("ban")

      }

      object Invite {

        /**
          * <h1>Signed</h1>
          *
          *  A block of content which has been signed, which servers can use to verify the event. Clients should ignore this.
          *
          * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
          */
        case class Signed(
            mxid: String,
            signatures: Map[String, Map[String, String]],
            token: String
        )

      }

      /**
        * <h1>Invite</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
        */
      case class Invite(
          display_name: String,
          signed: EventSchemas.MRoomMember.EventContent.Invite.Signed
      )

    }

    /**
      * <h1>EventContent</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
      */
    case class EventContent(
        avatar_url: Option[String] = None,
        displayname: Option[Option[String]] = None,
        membership: EventSchemas.MRoomMember.EventContent.MembershipEnum.Value,
        is_direct: Option[Boolean] = None,
        join_authorised_via_users_server: Option[String] = None,
        reason: Option[String] = None,
        third_party_invite: Option[EventSchemas.MRoomMember.EventContent.Invite] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.member`: Value = Value("m.room.member")

    }

    object Unsigned {

      /**
        * <h1>Composite</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
        */
      case class Composite(
          invite_room_state: Option[Seq[Definitions.StrippedStateEvent]] = None,
          knock_room_state: Option[Seq[Definitions.StrippedStateEvent]] = None
      )

    }

    /**
      * <h1>Unsigned</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
      */
    case class Unsigned(
        //composite start Definitions.UnsignedData
        age: Option[Int] = None,
        // composite end

        //composite start EventSchemas.MRoomMember.Unsigned.Composite
        invite_room_state: Option[Seq[Definitions.StrippedStateEvent]] = None,
        knock_room_state: Option[Seq[Definitions.StrippedStateEvent]] = None

        // composite end
    )

  }

  /**
    * <h1>MRoomMember</h1>
    *
    *  Adjusts the membership state for a user in a room. It is preferable to use the membership APIs (`/rooms/<room id>/invite` etc) when performing membership actions rather than adjusting the state directly as there are a restricted set of valid transformations. For example, user A cannot force user B to join a room, and trying to force this state change directly will fail.
    *
    * The following membership states are specified:
    *
    * - `invite` - The user has been invited to join a room, but has not yet joined it. They may not participate in the room until they join.
    * - `join` - The user has joined the room (possibly after accepting an invite), and may participate in it.
    * - `leave` - The user was once joined to the room, but has since left (possibly by choice, or possibly by being kicked).
    * - `ban` - The user has been banned from the room, and is no longer allowed to join it until they are un-banned from the room (by having their membership state set to a value other than `ban`).
    * - `knock` - The user has knocked on the room, requesting permission to participate. They may not participate in the room until they join.
    *
    * The `third_party_invite` property will be set if this invite is an `invite` event and is the successor of an `m.room.third_party_invite` event, and absent otherwise.
    *
    * This event may also include an `invite_room_state` key inside the event's `unsigned` data.
    * If present, this contains an array of [stripped state events](/client-server-api/#stripped-state)
    * to assist the receiver in identifying the room.
    *
    * The user for which a membership applies is represented by the `state_key`. Under some conditions,
    * the `sender` and `state_key` may not match - this may be interpreted as the `sender` affecting
    * the membership state of the `state_key` user.
    *
    * The `membership` for a given user can change over time. The table below represents the various changes
    * over time and how clients and servers must interpret those changes. Previous membership can be retrieved
    * from the `prev_content` object on an event. If not present, the user's previous membership must be assumed
    * as `leave`.
    *
    * |                   | to `invite`          | to `join`                              | to `leave`                                                                                                                              | to `ban`                    | to `knock`           |
    * |-------------------|----------------------|----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|----------------------|
    * | **from `invite`** | No change.           | User joined the room.                  | If the `state_key` is the same as the `sender`, the user rejected the invite. Otherwise, the `state_key` user had their invite revoked. | User was banned.            | User is re-knocking. |
    * | **from `join`**   | Must never happen.   | `displayname` or `avatar_url` changed. | If the `state_key` is the same as the `sender`, the user left. Otherwise, the `state_key` user was kicked.                              | User was kicked and banned. | Must never happen.   |
    * | **from `leave`**  | New invitation sent. | User joined.                           | No change.                                                                                                                              | User was banned.            | User is knocking.    |
    * | **from `ban`**    | Must never happen.   | Must never happen.                     | User was unbanned.                                                                                                                      | No change.                  | Must never happen.   |
    * | **from `knock`**  | Knock accepted.      | Must never happen.                     | If the `state_key` is the same as the `sender`, the user retracted the knock. Otherwise, the `state_key` user had their knock denied.   | User was banned.            | No change.           |
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.member.yaml"
    */
  case class MRoomMember(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomMember.EventContent] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomMember.TypeEnum.Value] = None,
      unsigned: Option[EventSchemas.MRoomMember.Unsigned] = None
  )

  object MPresence {

    object Content {

      object PresenceEnum extends Enumeration {

        val `online`: Value = Value("online")

        val `offline`: Value = Value("offline")

        val `unavailable`: Value = Value("unavailable")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.presence.yaml"
      */
    case class Content(
        avatar_url: Option[String] = None,
        displayname: Option[String] = None,
        last_active_ago: Option[Double] = None,
        presence: EventSchemas.MPresence.Content.PresenceEnum.Value,
        currently_active: Option[Boolean] = None,
        status_msg: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.presence`: Value = Value("m.presence")

    }

  }

  /**
    * <h1>MPresence</h1>
    *
    *  Informs the client of a user's presence state change.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.presence.yaml"
    */
  case class MPresence(
      //composite start Definitions.Event

      // composite end
      content: EventSchemas.MPresence.Content,
      `type`: EventSchemas.MPresence.TypeEnum.Value = EventSchemas.MPresence.TypeEnum.`m.presence`,
      sender: String
  )

  object MKeyVerificationReady {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.ready.yaml"
      */
    case class Content(
        from_device: String,
        transaction_id: Option[String] = None,
        methods: Seq[String],
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.ready`: Value = Value("m.key.verification.ready")

    }

  }

  /**
    * <h1>MKeyVerificationReady</h1>
    *
    *  Accepts a key verification request. Sent in response to an
    * `m.key.verification.request` event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.ready.yaml"
    */
  case class MKeyVerificationReady(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationReady.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationReady.TypeEnum.Value] = None
  )

  object MKeyVerificationMRelatesTo {

    object RelTypeEnum extends Enumeration {

      val `m.reference`: Value = Value("m.reference")

    }

  }

  /**
    * <h1>MKeyVerificationMRelatesTo</h1>
    *
    *  Required when sent as an in-room message. Indicates the
    * `m.key.verification.request` that this message is related to. Note that for
    * encrypted messages, this property should be in the unencrypted portion of the
    * event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.m.relates_to.yaml"
    */
  case class MKeyVerificationMRelatesTo(
      rel_type: Option[EventSchemas.MKeyVerificationMRelatesTo.RelTypeEnum.Value] = None,
      event_id: Option[String] = None
  )

  object MRoomTopic {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.topic.yaml"
      */
    case class Content(
        topic: String
    )

    object TypeEnum extends Enumeration {

      val `m.room.topic`: Value = Value("m.room.topic")

    }

  }

  /**
    * <h1>MRoomTopic</h1>
    *
    *  A topic is a short message detailing what is currently being discussed in the room.  It can also be used as a way to display extra information about the room, which may not be suitable for the room name. The room topic can also be set when creating a room using `/createRoom` with the `topic` key.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.topic.yaml"
    */
  case class MRoomTopic(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomTopic.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomTopic.TypeEnum.Value] = None
  )

  object MPolicyRuleServer {

    object TypeEnum extends Enumeration {

      val `m.policy.rule.server`: Value = Value("m.policy.rule.server")

    }

  }

  /**
    * <h1>MPolicyRuleServer</h1>
    *
    *  A moderation policy rule which affects servers.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.policy.rule.server.yaml"
    */
  case class MPolicyRuleServer(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[Definitions.ModerationPolicyRule] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MPolicyRuleServer.TypeEnum.Value] = None
  )

  object MKeyVerificationStartMReciprocateV1 {

    object Content {

      object MethodEnum extends Enumeration {

        val `m.reciprocate.v1`: Value = Value("m.reciprocate.v1")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start$m.reciprocate.v1.yaml"
      */
    case class Content(
        from_device: String,
        transaction_id: Option[String] = None,
        method: EventSchemas.MKeyVerificationStartMReciprocateV1.Content.MethodEnum.Value =
          EventSchemas.MKeyVerificationStartMReciprocateV1.Content.MethodEnum.`m.reciprocate.v1`,
        secret: String,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.start`: Value = Value("m.key.verification.start")

    }

  }

  /**
    * <h1>MKeyVerificationStartMReciprocateV1</h1>
    *
    *  Begins a key verification process using the `m.reciprocate.v1` method, after
    * scanning a QR code.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.start$m.reciprocate.v1.yaml"
    */
  case class MKeyVerificationStartMReciprocateV1(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationStartMReciprocateV1.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationStartMReciprocateV1.TypeEnum.Value] = None
  )

  object MRoomKeyWithheld {

    object Content {

      object AlgorithmEnum extends Enumeration {

        val `m.megolm.v1.aes-sha2`: Value = Value("m.megolm.v1.aes-sha2")

      }

      object CodeEnum extends Enumeration {

        val `m.blacklisted`: Value = Value("m.blacklisted")

        val `m.unverified`: Value = Value("m.unverified")

        val `m.unauthorised`: Value = Value("m.unauthorised")

        val `m.unavailable`: Value = Value("m.unavailable")

        val `m.no_olm`: Value = Value("m.no_olm")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key.withheld.yaml"
      */
    case class Content(
        algorithm: EventSchemas.MRoomKeyWithheld.Content.AlgorithmEnum.Value =
          EventSchemas.MRoomKeyWithheld.Content.AlgorithmEnum.`m.megolm.v1.aes-sha2`,
        room_id: Option[String] = None,
        session_id: Option[String] = None,
        sender_key: String,
        code: EventSchemas.MRoomKeyWithheld.Content.CodeEnum.Value,
        reason: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room_key.withheld`: Value = Value("m.room_key.withheld")

    }

  }

  /**
    * <h1>MRoomKeyWithheld</h1>
    *
    *  This event type is used to indicate that the sender is not sharing room keys
    * with the recipient. It is sent as a to-device event.
    *
    * Possible values for `code` include:
    *
    * `m.blacklisted`: the user/device was blacklisted.
    * `m.unverified`: the user/device was not verified, and the sender is only
    *  sharing keys with verified users/devices.
    * `m.unauthorised`: the user/device is not allowed to have the key. For
    *  example, this could be sent in response to a key request if the user/device
    *  was not in the room when the original message was sent.
    * `m.unavailable`: sent in reply to a key request if the device that the
    *  key is requested from does not have the requested key.
    * `m.no_olm`: an olm session could not be established.
    *
    * In most cases, this event refers to a specific room key. The one exception to
    * this is when the sender is unable to establish an olm session with the
    * recipient. When this happens, multiple sessions will be affected.  In order
    * to avoid filling the recipient\'s device mailbox, the sender should only send
    * one `m.room_key.withheld` message with no `room_id` nor `session_id`
    * set.  If the sender retries and fails to create an olm session again in the
    * future, it should not send another `m.room_key.withheld` message with a
    * `code` of `m.no_olm`, unless another olm session was previously
    * established successfully.  In response to receiving an
    * `m.room_key.withheld` message with a `code` of `m.no_olm`, the
    * recipient may start an olm session with the sender and send an `m.dummy`
    * message to notify the sender of the new olm session.  The recipient may
    * assume that this `m.room_key.withheld` message applies to all encrypted
    * room messages sent before it receives the message.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room_key.withheld.yaml"
    */
  case class MRoomKeyWithheld(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MRoomKeyWithheld.Content] = None,
      `type`: Option[EventSchemas.MRoomKeyWithheld.TypeEnum.Value] = None
  )

  object MCallInvite {

    object Content {

      object Offer {

        object TypeEnum extends Enumeration {

          val `offer`: Value = Value("offer")

        }

      }

      /**
        * <h1>Offer</h1>
        *
        *  The session description object
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.invite.yaml"
        */
      case class Offer(
          `type`: EventSchemas.MCallInvite.Content.Offer.TypeEnum.Value =
            EventSchemas.MCallInvite.Content.Offer.TypeEnum.`offer`,
          sdp: String
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.invite.yaml"
      */
    case class Content(
        call_id: String,
        offer: EventSchemas.MCallInvite.Content.Offer,
        version: Int,
        lifetime: Int
    )

    object TypeEnum extends Enumeration {

      val `m.call.invite`: Value = Value("m.call.invite")

    }

  }

  /**
    * <h1>MCallInvite</h1>
    *
    *  This event is sent by the caller when they wish to establish a call.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.invite.yaml"
    */
  case class MCallInvite(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MCallInvite.Content] = None,
      `type`: Option[EventSchemas.MCallInvite.TypeEnum.Value] = None
  )

  object MSecretRequest {

    object Content {

      object ActionEnum extends Enumeration {

        val `request`: Value = Value("request")

        val `request_cancellation`: Value = Value("request_cancellation")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.secret.request.yaml"
      */
    case class Content(
        name: Option[String] = None,
        action: EventSchemas.MSecretRequest.Content.ActionEnum.Value,
        requesting_device_id: String,
        request_id: String
    )

    object TypeEnum extends Enumeration {

      val `m.secret.request`: Value = Value("m.secret.request")

    }

  }

  /**
    * <h1>MSecretRequest</h1>
    *
    *  Sent by a client to request a secret from another device or to cancel a
    * previous request. It is sent as an unencrypted to-device event.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.secret.request.yaml"
    */
  case class MSecretRequest(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MSecretRequest.Content] = None,
      `type`: Option[EventSchemas.MSecretRequest.TypeEnum.Value] = None
  )

  object MRoomEncryption {

    object Content {

      object AlgorithmEnum extends Enumeration {

        val `m.megolm.v1.aes-sha2`: Value = Value("m.megolm.v1.aes-sha2")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.encryption.yaml"
      */
    case class Content(
        algorithm: EventSchemas.MRoomEncryption.Content.AlgorithmEnum.Value =
          EventSchemas.MRoomEncryption.Content.AlgorithmEnum.`m.megolm.v1.aes-sha2`,
        rotation_period_ms: Option[Int] = None,
        rotation_period_msgs: Option[Int] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.encryption`: Value = Value("m.room.encryption")

    }

  }

  /**
    * <h1>MRoomEncryption</h1>
    *
    *  Defines how messages sent in this room should be encrypted.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.encryption.yaml"
    */
  case class MRoomEncryption(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MRoomEncryption.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MRoomEncryption.TypeEnum.Value] = None
  )

  object MDirect {

    object TypeEnum extends Enumeration {

      val `m.direct`: Value = Value("m.direct")

    }

  }

  /**
    * <h1>MDirect</h1>
    *
    *  A map of which rooms are considered 'direct' rooms for specific users
    * is kept in  `account_data` in an event of type `m.direct`. The
    * content of this event is an object where the keys are the user IDs
    * and values are lists of room ID strings of the 'direct' rooms for
    * that user ID.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.direct.yaml"
    */
  case class MDirect(
      //composite start Definitions.Event

      // composite end
      content: Option[Map[String, Seq[String]]] = None,
      `type`: Option[EventSchemas.MDirect.TypeEnum.Value] = None
  )

  object MRoomMessageMNotice {

    object Content {

      object MsgtypeEnum extends Enumeration {

        val `m.notice`: Value = Value("m.notice")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.notice.yaml"
      */
    case class Content(
        body: String,
        msgtype: EventSchemas.MRoomMessageMNotice.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMNotice.Content.MsgtypeEnum.`m.notice`,
        format: Option[String] = None,
        formatted_body: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMNotice</h1>
    *
    *  The `m.notice` type is primarily intended for responses from automated clients. An `m.notice` message must be treated the same way as a regular `m.text` message with two exceptions. Firstly, clients should present `m.notice` messages to users in a distinct manner, and secondly, `m.notice` messages must never be automatically responded to. This helps to prevent infinite-loop situations where two automated clients continuously exchange messages.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.notice.yaml"
    */
  case class MRoomMessageMNotice(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMNotice.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMNotice.TypeEnum.Value] = None
  )

  object MCallCandidates {

    object Content {

      /**
        * <h1>Candidate</h1>
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.candidates.yaml"
        */
      case class Candidate(
          sdpMid: String,
          sdpMLineIndex: Double,
          candidate: String
      )

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.candidates.yaml"
      */
    case class Content(
        call_id: String,
        candidates: Seq[EventSchemas.MCallCandidates.Content.Candidate],
        version: Int
    )

    object TypeEnum extends Enumeration {

      val `m.call.candidates`: Value = Value("m.call.candidates")

    }

  }

  /**
    * <h1>MCallCandidates</h1>
    *
    *  This event is sent by callers after sending an invite and by the callee after answering. Its purpose is to give the other party additional ICE candidates to try using to communicate.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.call.candidates.yaml"
    */
  case class MCallCandidates(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MCallCandidates.Content] = None,
      `type`: Option[EventSchemas.MCallCandidates.TypeEnum.Value] = None
  )

  object MRoomRedaction {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.redaction.yaml"
      */
    case class Content(
        reason: Option[String] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.redaction`: Value = Value("m.room.redaction")

    }

  }

  /**
    * <h1>MRoomRedaction</h1>
    *
    *  This event is created by the server to describe which event has been redacted, by whom, and optionally why. The event that has been redacted is specified in the `redacts` event level key. Redacting an event means that all keys not required by the protocol are stripped off, allowing messages to be hidden or allowing admins to remove offensive or illegal content.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.redaction.yaml"
    */
  case class MRoomRedaction(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomRedaction.Content] = None,
      redacts: String,
      `type`: Option[EventSchemas.MRoomRedaction.TypeEnum.Value] = None
  )

  object MKeyVerificationDone {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.done.yaml"
      */
    case class Content(
        transaction_id: Option[String] = None,
        `m.relates_to`: Option[Definitions.VerificationRelatesTo] = None
    )

    object TypeEnum extends Enumeration {

      val `m.key.verification.done`: Value = Value("m.key.verification.done")

    }

  }

  /**
    * <h1>MKeyVerificationDone</h1>
    *
    *  Indicates that a verification process/request has completed successfully.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.key.verification.done.yaml"
    */
  case class MKeyVerificationDone(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MKeyVerificationDone.Content] = None,
      `type`: Option[EventSchemas.MKeyVerificationDone.TypeEnum.Value] = None
  )

  object MAcceptedTerms {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.accepted_terms.yaml"
      */
    case class Content(
        accepted: Option[Seq[String]] = None
    )

    object TypeEnum extends Enumeration {

      val `m.accepted_terms`: Value = Value("m.accepted_terms")

    }

  }

  /**
    * <h1>MAcceptedTerms</h1>
    *
    *  A list of terms URLs the user has previously accepted. Clients SHOULD use this
    * to avoid presenting the user with terms they have already agreed to.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.accepted_terms.yaml"
    */
  case class MAcceptedTerms(
      //composite start Definitions.Event

      // composite end
      content: Option[EventSchemas.MAcceptedTerms.Content] = None,
      `type`: Option[EventSchemas.MAcceptedTerms.TypeEnum.Value] = None
  )

  object MRoomMessageMAudio {

    object Content {

      /**
        * <h1>AudioInfo</h1>
        *
        *  Metadata for the audio clip referred to in `url`.
        *
        * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.audio.yaml"
        */
      case class AudioInfo(
          duration: Option[Int] = None,
          mimetype: Option[String] = None,
          size: Option[Int] = None
      )

      object MsgtypeEnum extends Enumeration {

        val `m.audio`: Value = Value("m.audio")

      }

    }

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.audio.yaml"
      */
    case class Content(
        body: String,
        info: Option[EventSchemas.MRoomMessageMAudio.Content.AudioInfo] = None,
        msgtype: EventSchemas.MRoomMessageMAudio.Content.MsgtypeEnum.Value =
          EventSchemas.MRoomMessageMAudio.Content.MsgtypeEnum.`m.audio`,
        url: Option[String] = None,
        file: Option[JsObject] = None
    )

    object TypeEnum extends Enumeration {

      val `m.room.message`: Value = Value("m.room.message")

    }

  }

  /**
    * <h1>MRoomMessageMAudio</h1>
    *
    *  This message represents a single audio clip.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.room.message$m.audio.yaml"
    */
  case class MRoomMessageMAudio(
      //composite start Definitions.RoomEvent
      room_id: String,
      // composite end
      content: Option[EventSchemas.MRoomMessageMAudio.Content] = None,
      `type`: Option[EventSchemas.MRoomMessageMAudio.TypeEnum.Value] = None
  )

  object MSpaceParent {

    /**
      * <h1>Content</h1>
      *
      * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.space.parent.yaml"
      */
    case class Content(
        via: Option[Seq[String]] = None,
        canonical: Option[Boolean] = None
    )

    object TypeEnum extends Enumeration {

      val `m.space.parent`: Value = Value("m.space.parent")

    }

  }

  /**
    * <h1>MSpaceParent</h1>
    *
    *  Defines the relationship of a room to a parent space-room.
    *
    * @see "defined in ./build/matrix-spec/data/event-schemas/schema/m.space.parent.yaml"
    */
  case class MSpaceParent(
      //composite start Definitions.StateEvent

      // composite end
      content: Option[EventSchemas.MSpaceParent.Content] = None,
      state_key: Option[String] = None,
      `type`: Option[EventSchemas.MSpaceParent.TypeEnum.Value] = None
  )

}
