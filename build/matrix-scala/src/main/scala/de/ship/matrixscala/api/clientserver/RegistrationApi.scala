/**
  * <h1>matrix-scala</h1>
  * @version 1.0.0
  * @author kirill.sokol@uk-essen.de
  *
  * This file was generated.
  *
  * DO NOT EDIT THIS FILE. Any changes to this file will be overwritten
  * the next time the code is generated. If you need to modify the code
  * generated by this tool, make your changes to the generator script
  * and regenerate the code.
  */

package de.ship.matrixscala.api.clientserver

import de.ship.matrixscala.model.Definitions
import de.ship.matrixscala.model.clientserver.RegistrationData._
import de.ship.matrixscala.json.clientserver.RegistrationJsonFormats._
import de.ship.matrixscala.json.DefinitionFormats._
import de.ship.matrixscala.core._
import de.ship.matrixscala.core.ResponseMappings._
import de.ship.matrixscala.core.QueryBuilding._
import de.ship.matrixscala.core.HeaderBuilding._
import akka.http.scaladsl.model.HttpMethods
import spray.json.{JsObject, JsValue, RootJsonFormat}
import spray.json.DefaultJsonProtocol._

/**
  * @see "defined in ./build/matrix-spec/data/api/client-server/registration.yaml"
  */
object RegistrationApi {

  /**
    * <h1>register</h1>
    *
    * This API endpoint uses the [User-Interactive Authentication API](/client-server-api/#user-interactive-authentication-api), except in
    * the cases where a guest account is being registered.
    *
    * Register for an account on this homeserver.
    *
    * There are two kinds of user account:
    *
    * - `user` accounts. These accounts may use the full API described in this specification.
    *
    * - `guest` accounts. These accounts may have limited permissions and may not be supported by all servers.
    *
    * If registration is successful, this endpoint will issue an access token
    * the client can use to authorize itself in subsequent requests.
    *
    * If the client does not supply a `device_id`, the server must
    * auto-generate one.
    *
    * The server SHOULD register an account with a User ID based on the
    * `username` provided, if any. Note that the grammar of Matrix User ID
    * localparts is restricted, so the server MUST either map the provided
    * `username` onto a `user_id` in a logical manner, or reject any
    * `username` which does not comply to the grammar with
    * `M_INVALID_USERNAME`.
    *
    * Matrix clients MUST NOT assume that localpart of the registered
    * `user_id` matches the provided `username`.
    *
    * The returned access token must be associated with the `device_id`
    * supplied by the client or generated by the server. The server may
    * invalidate any access token previously associated with that device. See
    * [Relationship between access tokens and devices](/client-server-api/#relationship-between-access-tokens-and-devices).
    *
    * When registering a guest account, all parameters in the request body
    * with the exception of `initial_device_display_name` MUST BE ignored
    * by the server. The server MUST pick a `device_id` for the account
    * regardless of input.
    *
    * Any user ID returned by this API must conform to the grammar given in the
    * [Matrix specification](/appendices/#user-identifiers).
    *
    * @param kind The kind of account to register. Defaults to `user`.
    */
  def register(
      body: Register.Body,
      kind: Option[String] = None
  ): ApiRequest[NoAuthentication, Register.Body, Register.OK] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/register",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[Register.Body]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[Register.OK]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Option[String]]("kind" -> kind)
      ),
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>requestTokenToRegisterEmail</h1>
    *
    * The homeserver must check that the given email address is **not**
    * already associated with an account on this homeserver. The homeserver
    * should validate the email itself, either by sending a validation email
    * itself or by using a service it has control over.
    */
  def requestTokenToRegisterEmail(
      body: JsObject
  ): ApiRequest[NoAuthentication, JsObject, Definitions.RequestTokenResponse] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/register/email/requestToken",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[Definitions.RequestTokenResponse]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>requestTokenToRegisterMSISDN</h1>
    *
    * The homeserver must check that the given phone number is **not**
    * already associated with an account on this homeserver. The homeserver
    * should validate the phone number itself, either by sending a validation
    * message itself or by using a service it has control over.
    */
  def requestTokenToRegisterMSISDN(
      body: JsObject
  ): ApiRequest[NoAuthentication, JsObject, Definitions.RequestTokenResponse] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/register/msisdn/requestToken",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[Definitions.RequestTokenResponse]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>changePassword</h1>
    *
    * Changes the password for an account on this homeserver.
    *
    * This API endpoint uses the [User-Interactive Authentication API](/client-server-api/#user-interactive-authentication-api) to
    * ensure the user changing the password is actually the owner of the
    * account.
    *
    * An access token should be submitted to this endpoint if the client has
    * an active session.
    *
    * The homeserver may change the flows available depending on whether a
    * valid access token is provided. The homeserver SHOULD NOT revoke the
    * access token provided in the request. Whether other access tokens for
    * the user are revoked depends on the request parameters.
    */
  def changePassword(
      body: ChangePassword.Body
  ): ApiRequest[AccessTokenAuthentication, ChangePassword.Body, JsObject] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/account/password",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[ChangePassword.Body]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[JsObject]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>requestTokenToResetPasswordEmail</h1>
    *
    * The homeserver must check that the given email address **is
    * associated** with an account on this homeserver. This API should be
    * used to request validation tokens when authenticating for the
    * `/account/password` endpoint.
    *
    * This API's parameters and response are identical to that of the
    * [`/register/email/requestToken`](/client-server-api/#post_matrixclientv3registeremailrequesttoken)
    * endpoint, except that
    * `M_THREEPID_NOT_FOUND` may be returned if no account matching the
    * given email address could be found. The server may instead send an
    * email to the given address prompting the user to create an account.
    * `M_THREEPID_IN_USE` may not be returned.
    *
    * The homeserver should validate the email itself, either by sending a
    * validation email itself or by using a service it has control over.
    */
  def requestTokenToResetPasswordEmail(
      body: JsObject
  ): ApiRequest[NoAuthentication, JsObject, Definitions.RequestTokenResponse] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/account/password/email/requestToken",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[Definitions.RequestTokenResponse]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>requestTokenToResetPasswordMSISDN</h1>
    *
    * The homeserver must check that the given phone number **is
    * associated** with an account on this homeserver. This API should be
    * used to request validation tokens when authenticating for the
    * `/account/password` endpoint.
    *
    * This API's parameters and response are identical to that of the
    * [`/register/msisdn/requestToken`](/client-server-api/#post_matrixclientv3registermsisdnrequesttoken)
    * endpoint, except that
    * `M_THREEPID_NOT_FOUND` may be returned if no account matching the
    * given phone number could be found. The server may instead send the SMS
    * to the given phone number prompting the user to create an account.
    * `M_THREEPID_IN_USE` may not be returned.
    *
    * The homeserver should validate the phone number itself, either by sending a
    * validation message itself or by using a service it has control over.
    */
  def requestTokenToResetPasswordMSISDN(
      body: JsObject
  ): ApiRequest[NoAuthentication, JsObject, Definitions.RequestTokenResponse] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/account/password/msisdn/requestToken",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[Definitions.RequestTokenResponse]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>deactivateAccount</h1>
    *
    * Deactivate the user's account, removing all ability for the user to
    * login again.
    *
    * This API endpoint uses the [User-Interactive Authentication API](/client-server-api/#user-interactive-authentication-api).
    *
    * An access token should be submitted to this endpoint if the client has
    * an active session.
    *
    * The homeserver may change the flows available depending on whether a
    * valid access token is provided.
    *
    * Unlike other endpoints, this endpoint does not take an `id_access_token`
    * parameter because the homeserver is expected to sign the request to the
    * identity server instead.
    */
  def deactivateAccount(
      body: DeactivateAccount.Body
  ): ApiRequest[AccessTokenAuthentication, DeactivateAccount.Body, DeactivateAccount.OK] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/account/deactivate",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[DeactivateAccount.Body]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[DeactivateAccount.OK]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>checkUsernameAvailability</h1>
    *
    * Checks to see if a username is available, and valid, for the server.
    *
    * The server should check to ensure that, at the time of the request, the
    * username requested is available for use. This includes verifying that an
    * application service has not claimed the username and that the username
    * fits the server's desired requirements (for example, a server could dictate
    * that it does not permit usernames with underscores).
    *
    * Matrix clients may wish to use this API prior to attempting registration,
    * however the clients must also be aware that using this API does not normally
    * reserve the username. This can mean that the username becomes unavailable
    * between checking its availability and attempting to register it.
    *
    * @param username The username to check the availability of.
    */
  def checkUsernameAvailability(
      username: String
  ): ApiRequest[NoAuthentication, JsObject, CheckUsernameAvailability.OK] =
    ApiRequest(
      endpoint = "/_matrix/client/v3/register/available",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[CheckUsernameAvailability.OK]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[String]("username" -> username)
      ),
      inPath = Map.empty,
      inHeader = Map.empty
    )

}
