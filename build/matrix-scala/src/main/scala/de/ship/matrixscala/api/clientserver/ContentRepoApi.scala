/**
  * <h1>matrix-scala</h1>
  * @version 1.0.0
  * @author kirill.sokol@uk-essen.de
  *
  * This file was generated.
  *
  * DO NOT EDIT THIS FILE. Any changes to this file will be overwritten
  * the next time the code is generated. If you need to modify the code
  * generated by this tool, make your changes to the generator script
  * and regenerate the code.
  */

package de.ship.matrixscala.api.clientserver

import de.ship.matrixscala.model.Definitions
import de.ship.matrixscala.model.clientserver.ContentRepoData._
import de.ship.matrixscala.json.clientserver.ContentRepoJsonFormats._
import de.ship.matrixscala.json.DefinitionFormats._
import de.ship.matrixscala.core._
import de.ship.matrixscala.core.ResponseMappings._
import de.ship.matrixscala.core.QueryBuilding._
import de.ship.matrixscala.core.HeaderBuilding._
import akka.http.scaladsl.model.HttpMethods
import spray.json.{JsObject, JsValue, RootJsonFormat}
import spray.json.DefaultJsonProtocol._

/**
  * @see "defined in ./build/matrix-spec/data/api/client-server/content-repo.yaml"
  */
object ContentRepoApi {

  /**
    * <h1>uploadContent</h1>
    *
    * @param filename The name of the file being uploaded
    *
    * @param Content-Type The content type of the file being uploaded
    */
  def uploadContent(
      body: JsObject,
      filename: Option[String] = None,
      `Content-Type`: Option[String] = None
  ): ApiRequest[AccessTokenAuthentication, JsObject, UploadContent.OK] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/upload",
      httpMethod = HttpMethods.POST,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[UploadContent.OK]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Option[String]]("filename" -> filename)
      ),
      inPath = Map.empty,
      inHeader = buildHeaders(
        fromHeaderEntry[Option[String]]("Content-Type" -> `Content-Type`)
      )
    )

  /**
    * <h1>uploadContentToMXC</h1>
    *
    * This endpoint permits uploading content to an `mxc://` URI that was created
    * earlier via [POST /_matrix/media/v1/create](/client-server-api/#post_matrixmediav1create).
    *
    * @param serverName The server name from the `mxc://` URI returned by `POST /_matrix/media/v1/create` (the authoritory component).
    *
    * @param mediaId The media ID from the `mxc://` URI returned by `POST /_matrix/media/v1/create` (the path component).
    *
    * @param filename The name of the file being uploaded
    *
    * @param Content-Type The content type of the file being uploaded
    */
  def uploadContentToMXC(
      body: JsObject,
      serverName: String,
      mediaId: String,
      filename: Option[String] = None,
      `Content-Type`: Option[String] = None
  ): ApiRequest[NoAuthentication, JsObject, JsObject] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/upload/{serverName}/{mediaId}",
      httpMethod = HttpMethods.PUT,
      body = body,
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[JsObject]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Option[String]]("filename" -> filename)
      ),
      inPath = Map(
        "serverName" -> serverName,
        "mediaId"    -> mediaId
      ),
      inHeader = buildHeaders(
        fromHeaderEntry[Option[String]]("Content-Type" -> `Content-Type`)
      )
    )

  /**
    * <h1>createContent</h1>
    *
    * Creates a new `mxc://` URI, independently of the content being uploaded. The content must be provided later
    * via [`PUT /_matrix/media/v3/upload/{serverName}/{mediaId}`](http://localhost:1313/client-server-api/#put_matrixmediav3uploadservernamemediaid).
    *
    * The server may optionally enforce a maximum age for unused IDs,
    * and delete media IDs when the client doesn't start the upload in time,
    * or when the upload was interrupted and not resumed in time. The server
    * should include the maximum POSIX millisecond timestamp to complete the
    * upload in the `unused_expires_at` field in the response JSON. The
    * recommended default expiration is 24 hours which should be enough time
    * to accommodate users on poor connection who find a better connection to
    * complete the upload.
    *
    * As well as limiting the rate of requests to create `mxc://` URIs, the server
    * should limit the number of concurrent *pending media uploads* a given
    * user can have. A pending media upload is a created `mxc://` URI where (a)
    * the media has not yet been uploaded, and (b) has not yet expired (the
    * `unused_expires_at` timestamp has not yet passed). In both cases, the
    * server should respond with an HTTP 429 error with an errcode of
    * `M_LIMIT_EXCEEDED`.
    */
  def createContent(
  ): ApiRequest[AccessTokenAuthentication, JsObject, CreateContent.OK] =
    ApiRequest(
      endpoint = "/_matrix/media/v1/create",
      httpMethod = HttpMethods.POST,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[CreateContent.OK]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>getContent</h1>
    *
    * @param serverName The server name from the `mxc://` URI (the authoritory component)
    *
    * @param mediaId The media ID from the `mxc://` URI (the path component)
    *
    * @param allow_remote Indicates to the server that it should not attempt to fetch the media if it is deemed
    * remote. This is to prevent routing loops where the server contacts itself. Defaults to
    * true if not provided.
    *
    * @param timeout_ms The maximum number of milliseconds that the client is willing to
    * wait to start receiving data, in the case that the content has not
    * yet been uploaded. The default value is 20000 (20 seconds). The
    * content repository can and should impose a maximum value for this
    * parameter. The content repository may also choose to respond before
    * the timeout.
    */
  def getContent(
      serverName: String,
      mediaId: String,
      allow_remote: Option[Boolean] = None,
      timeout_ms: Option[Long] = None
  ): ApiRequest[NoAuthentication, JsObject, JsObject] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/download/{serverName}/{mediaId}",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[JsObject]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Option[Boolean]]("allow_remote" -> allow_remote),
        fromQueryEntry[Option[Long]]("timeout_ms"      -> timeout_ms)
      ),
      inPath = Map(
        "serverName" -> serverName,
        "mediaId"    -> mediaId
      ),
      inHeader = Map.empty
    )

  /**
    * <h1>getContentOverrideName</h1>
    *
    * This will download content from the content repository (same as
    * the previous endpoint) but replace the target file name with the one
    * provided by the caller.
    *
    * @param serverName The server name from the `mxc://` URI (the authoritory component)
    *
    * @param mediaId The media ID from the `mxc://` URI (the path component)
    *
    * @param fileName A filename to give in the `Content-Disposition` header.
    *
    * @param allow_remote Indicates to the server that it should not attempt to fetch the media if it is deemed
    * remote. This is to prevent routing loops where the server contacts itself. Defaults to
    * true if not provided.
    *
    * @param timeout_ms The maximum number of milliseconds that the client is willing to
    * wait to start receiving data, in the case that the content has not
    * yet been uploaded. The default value is 20000 (20 seconds). The
    * content repository can and should impose a maximum value for this
    * parameter. The content repository may also choose to respond before
    * the timeout.
    */
  def getContentOverrideName(
      serverName: String,
      mediaId: String,
      fileName: String,
      allow_remote: Option[Boolean] = None,
      timeout_ms: Option[Long] = None
  ): ApiRequest[NoAuthentication, JsObject, JsObject] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/download/{serverName}/{mediaId}/{fileName}",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[JsObject]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Option[Boolean]]("allow_remote" -> allow_remote),
        fromQueryEntry[Option[Long]]("timeout_ms"      -> timeout_ms)
      ),
      inPath = Map(
        "serverName" -> serverName,
        "mediaId"    -> mediaId,
        "fileName"   -> fileName
      ),
      inHeader = Map.empty
    )

  /**
    * <h1>getContentThumbnail</h1>
    *
    * Download a thumbnail of content from the content repository.
    * See the [Thumbnails](/client-server-api/#thumbnails) section for more information.
    *
    * @param serverName The server name from the `mxc://` URI (the authoritory component)
    *
    * @param mediaId The media ID from the `mxc://` URI (the path component)
    *
    * @param width The *desired* width of the thumbnail. The actual thumbnail may be
    * larger than the size specified.
    *
    * @param height The *desired* height of the thumbnail. The actual thumbnail may be
    * larger than the size specified.
    *
    * @param method The desired resizing method. See the [Thumbnails](/client-server-api/#thumbnails)
    * section for more information.
    *
    * @param allow_remote Indicates to the server that it should not attempt to fetch
    * the media if it is deemed remote. This is to prevent routing loops
    * where the server contacts itself. Defaults to true if not provided.
    *
    * @param timeout_ms The maximum number of milliseconds that the client is willing to
    * wait to start receiving data, in the case that the content has not
    * yet been uploaded. The default value is 20000 (20 seconds). The
    * content repository can and should impose a maximum value for this
    * parameter. The content repository may also choose to respond before
    * the timeout.
    */
  def getContentThumbnail(
      serverName: String,
      mediaId: String,
      width: Int,
      height: Int,
      method: Option[String] = None,
      allow_remote: Option[Boolean] = None,
      timeout_ms: Option[Long] = None
  ): ApiRequest[NoAuthentication, JsObject, JsObject] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/thumbnail/{serverName}/{mediaId}",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[JsObject]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[Int]("width"                    -> width),
        fromQueryEntry[Int]("height"                   -> height),
        fromQueryEntry[Option[String]]("method"        -> method),
        fromQueryEntry[Option[Boolean]]("allow_remote" -> allow_remote),
        fromQueryEntry[Option[Long]]("timeout_ms"      -> timeout_ms)
      ),
      inPath = Map(
        "serverName" -> serverName,
        "mediaId"    -> mediaId
      ),
      inHeader = Map.empty
    )

  /**
    * <h1>getUrlPreview</h1>
    *
    * Get information about a URL for the client. Typically this is called when a
    * client sees a URL in a message and wants to render a preview for the user.
    *
    * *Note:**
    * Clients should consider avoiding this endpoint for URLs posted in encrypted
    * rooms. Encrypted rooms often contain more sensitive information the users
    * do not want to share with the homeserver, and this can mean that the URLs
    * being shared should also not be shared with the homeserver.
    *
    * @param url The URL to get a preview of.
    *
    * @param ts The preferred point in time to return a preview for. The server may
    * return a newer version if it does not have the requested version
    * available.
    */
  def getUrlPreview(
      url: String,
      ts: Option[Long] = None
  ): ApiRequest[AccessTokenAuthentication, JsObject, GetUrlPreview.OK] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/preview_url",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[GetUrlPreview.OK]])
      ),
      inQuery = buildQuery(
        fromQueryEntry[String]("url"      -> url),
        fromQueryEntry[Option[Long]]("ts" -> ts)
      ),
      inPath = Map.empty,
      inHeader = Map.empty
    )

  /**
    * <h1>getConfig</h1>
    *
    * This endpoint allows clients to retrieve the configuration of the content
    * repository, such as upload limitations.
    * Clients SHOULD use this as a guide when using content repository endpoints.
    * All values are intentionally left optional. Clients SHOULD follow
    * the advice given in the field description when the field is not available.
    *
    * *NOTE:** Both clients and server administrators should be aware that proxies
    * between the client and the server may affect the apparent behaviour of content
    * repository APIs, for example, proxies may enforce a lower upload size limit
    * than is advertised by the server on this endpoint.
    */
  def getConfig(
  ): ApiRequest[AccessTokenAuthentication, JsObject, GetConfig.OK] =
    ApiRequest(
      endpoint = "/_matrix/media/v3/config",
      httpMethod = HttpMethods.GET,
      body = JsObject(),
      bodyFormat = implicitly[RootJsonFormat[JsObject]],
      responseMappings = Seq(
        SingleResponseMapping(200, implicitly[RootJsonFormat[GetConfig.OK]])
      ),
      inQuery = Map.empty,
      inPath = Map.empty,
      inHeader = Map.empty
    )

}
