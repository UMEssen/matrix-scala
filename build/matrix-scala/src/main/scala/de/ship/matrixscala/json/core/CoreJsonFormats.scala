/**
  * <h1>matrix-scala</h1>
  * @version 1.0.0
  * @author kirill.sokol@uk-essen.de
  *
  * This file was generated.
  *
  * DO NOT EDIT THIS FILE. Any changes to this file will be overwritten
  * the next time the code is generated. If you need to modify the code
  * generated by this tool, make your changes to the generator script
  * and regenerate the code.
  */

package de.ship.matrixscala.json.core

import de.ship.matrixscala.core._
import spray.json._
import DefaultJsonProtocol._
import scala.util.Try

object CoreJsonFormats {
  def responseBoxFormat[C: RootJsonFormat, T <: ResponseBox[C, T]](
      apply: (C) => T
  ): RootJsonFormat[T] = {
    object Format extends RootJsonFormat[T] {
      override def read(json: JsValue): T = apply(json.convertTo[C])
      override def write(obj: T): JsValue = obj.boxes.toJson
    }
    Format
  }

  //https://github.com/spray/spray-json/issues/200
  class EnumJsonConverter[T <: scala.Enumeration](enu: T) extends RootJsonFormat[T#Value] {
    override def write(obj: T#Value): JsValue = JsString(obj.toString)

    override def read(json: JsValue): T#Value = {
      json match {
        case JsString(txt) => enu.withName(txt)
        case somethingElse =>
          throw DeserializationException(
            s"Expected a value from enum $enu instead of $somethingElse"
          )
      }
    }
  }
  implicit object UnitJsonFormat extends RootJsonFormat[Unit] {
    def write(obj: Unit)          = JsNull
    def read(json: JsValue): Unit = ()
  }
  implicit val ApiErrorFormat: RootJsonFormat[ApiError] = jsonFormat2(ApiError)

  //TODO: this implementation is rather ... simplistic
  implicit def additionalFieldsFormat[U <: AdditionalFields[U, T]: JsonFormat, T: JsonFormat]
      : JsonFormat[AdditionalFields[U, T]] = {
    implicit case object GenericFormat extends JsonFormat[AdditionalFields[U, T]] {
      override def write(obj: AdditionalFields[U, T]): JsValue =
        (
          obj.data.toJson.asJsObject.fields ++ obj.additionalFields.toJson.asJsObject.fields
        ).toJson

      override def read(json: JsValue): AdditionalFields[U, T] = {
        val baseData = json.convertTo[U]
        val extra = (
          json.asJsObject.fields.toSeq.diff(baseData.toJson.asJsObject.fields.toSeq)
        ).map { case (key, jsValue) => (key, jsValue.convertTo[T]) }.toMap
        case object WithAddedFields extends AdditionalFields[U, T] {
          override def data: U                          = baseData
          override def additionalFields: Map[String, T] = extra
        }
        WithAddedFields
      }
    }
    GenericFormat
  }

  //TODO: this is so much verbosity and duplication here, it's embarrassing!
  //      I believe you could create a chain function,
  //      which either returns the element or calls the next chain-element.
  //      If the entire chain fails, throw an exception
  val unionErr: DeserializationException = new DeserializationException(
    "json does not match any union possibility"
  )
  implicit def union1Format[AT: JsonFormat]: JsonFormat[Union1[AT]] = {
    implicit case object GenericFormat extends JsonFormat[Union1[AT]] {
      override def read(json: JsValue): Union1[AT] =
        Try {
          A[AT, Nothing, Nothing, Nothing](json.convertTo[AT])
        }.getOrElse(throw unionErr)

      override def write(obj: Union1[AT]): JsValue =
        obj match {
          case A(value) => value.toJson
        }
    }
    GenericFormat
  }

  implicit def union2Format[AT: JsonFormat, BT: JsonFormat]: JsonFormat[Union2[AT, BT]] = {
    implicit case object GenericFormat extends JsonFormat[Union2[AT, BT]] {
      override def read(json: JsValue): Union2[AT, BT] =
        Try { A[AT, BT, Nothing, Nothing](json.convertTo[AT]) }.getOrElse(Try {
          B[AT, BT, Nothing, Nothing](json.convertTo[BT])
        }.getOrElse(throw unionErr))

      override def write(obj: Union2[AT, BT]): JsValue =
        obj match {
          case A(value) => value.toJson; case B(value) => value.toJson
        }
    }
    GenericFormat
  }

  implicit def union3Format[AT: JsonFormat, BT: JsonFormat, CT: JsonFormat]
      : JsonFormat[Union3[AT, BT, CT]] = {
    implicit case object GenericFormat extends JsonFormat[Union3[AT, BT, CT]] {
      override def read(json: JsValue): Union3[AT, BT, CT] =
        Try {
          A[AT, BT, CT, Nothing](json.convertTo[AT])
        }.getOrElse(
          Try {
            B[AT, BT, CT, Nothing](json.convertTo[BT])
          }.getOrElse(
            Try {
              C[AT, BT, CT, Nothing](json.convertTo[CT])
            }.getOrElse(throw unionErr)
          )
        )

      override def write(obj: Union3[AT, BT, CT]): JsValue =
        obj match {
          case A(value) => value.toJson; case B(value) => value.toJson;
          case C(value) => value.toJson
        }
    }
    GenericFormat
  }

  implicit def union4Format[AT: JsonFormat, BT: JsonFormat, CT: JsonFormat, DT: JsonFormat]
      : JsonFormat[Union4[AT, BT, CT, DT]] = {
    implicit case object GenericFormat extends JsonFormat[Union4[AT, BT, CT, DT]] {
      override def read(json: JsValue): Union4[AT, BT, CT, DT] =
        Try {
          A[AT, BT, CT, DT](json.convertTo[AT])
        }.getOrElse(
          Try {
            B[AT, BT, CT, DT](json.convertTo[BT])
          }.getOrElse(
            Try {
              C[AT, BT, CT, DT](json.convertTo[CT])
            }.getOrElse(
              Try {
                D[AT, BT, CT, DT](json.convertTo[DT])
              }.getOrElse(throw unionErr)
            )
          )
        )

      override def write(obj: Union4[AT, BT, CT, DT]): JsValue =
        obj match {
          case A(value) => value.toJson; case B(value) => value.toJson;
          case C(value) => value.toJson; case D(value) => value.toJson
        }
    }
    GenericFormat
  }
}

import CoreJsonFormats._
